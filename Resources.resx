<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ChromeApp" xml:space="preserve">
    <value>() =&gt; {
console.warn('testtt');    
  if (!window.chrome) {
        // Use the exact property descriptor found in headful Chrome
        // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`
        Object.defineProperty(window, 'chrome', {
          writable: true,
          enumerable: true,
          configurable: false, // note!
          value: {} // We'll extend that later
        })
      }

      // That means we're running headful and don't need to mock anything
      if ('app' in window.chrome) {
        return // Nothing to do here
      }

      const makeError = {
        ErrorInInvocation: fn =&gt; {
          const err = new TypeError(`Error in invocation of app.${fn}()`)
          return utils.stripErrorWithAnchor(
            err,
            `at ${fn} (eval at &lt;anonymous&gt;`
          )
        }
      }

      // There's a some static data in that property which doesn't seem to change,
      // we should periodically check for updates: `JSON.stringify(window.app, null, 2)`
      const STATIC_DATA = JSON.parse(
        `
{
  "isInstalled": false,
  "InstallState": {
    "DISABLED": "disabled",
    "INSTALLED": "installed",
    "NOT_INSTALLED": "not_installed"
  },
  "RunningState": {
    "CANNOT_RUN": "cannot_run",
    "READY_TO_RUN": "ready_to_run",
    "RUNNING": "running"
  }
}
        `.trim()
      )

      window.chrome.app = {
        ...STATIC_DATA,

        get isInstalled() {
          return false
        },

        getDetails: function getDetails() {
          if (arguments.length) {
            throw makeError.ErrorInInvocation(`getDetails`)
          }
          return null
        },
        getIsInstalled: function getDetails() {
          if (arguments.length) {
            throw makeError.ErrorInInvocation(`getIsInstalled`)
          }
          return false
        },
        runningState: function getDetails() {
          if (arguments.length) {
            throw makeError.ErrorInInvocation(`runningState`)
          }
          return 'cannot_run'
        }
      }
      utils.patchToStringNested(window.chrome.app)
    }</value>
  </data>
  <data name="Codec" xml:space="preserve">
    <value>() =&gt; {
      /**
       * Input might look funky, we need to normalize it so e.g. whitespace isn't an issue for our spoofing.
       *
       * @example
       * video/webm; codecs="vp8, vorbis"
       * video/mp4; codecs="avc1.42E01E"
       * audio/x-m4a;
       * audio/ogg; codecs="vorbis"
       * @param {String} arg
       */
      const parseInput = arg =&gt; {
        const [mime, codecStr] = arg.trim().split(';')
        let codecs = []
        if (codecStr &amp;&amp; codecStr.includes('codecs="')) {
          codecs = codecStr
            .trim()
            .replace(`codecs="`, '')
            .replace(`"`, '')
            .trim()
            .split(',')
            .filter(x =&gt; !!x)
            .map(x =&gt; x.trim())
        }
        return {
          mime,
          codecStr,
          codecs
        }
      }

      const canPlayType = {
        // Intercept certain requests
        apply: function(target, ctx, args) {
          if (!args || !args.length) {
            return target.apply(ctx, args)
          }
          const { mime, codecs } = parseInput(args[0])
          // This specific mp4 codec is missing in Chromium
          if (mime === 'video/mp4') {
            if (codecs.includes('avc1.42E01E')) {
              return 'probably'
            }
          }
          // This mimetype is only supported if no codecs are specified
          if (mime === 'audio/x-m4a' &amp;&amp; !codecs.length) {
            return 'maybe'
          }

          // This mimetype is only supported if no codecs are specified
          if (mime === 'audio/aac' &amp;&amp; !codecs.length) {
            return 'probably'
          }
          // Everything else as usual
          return target.apply(ctx, args)
        }
      }

      /* global HTMLMediaElement */
      utils.replaceWithProxy(
        HTMLMediaElement.prototype,
        'canPlayType',
        canPlayType
      )
    }</value>
  </data>
  <data name="FindRecaptchaScript" xml:space="preserve">
    <value>const findRecap = () =&gt; {
    if (typeof (___grecaptcha_cfg) !== 'undefined') {
        let cs = []
        for (let id in ___grecaptcha_cfg.clients) {
            cs.push(id)
        }
        let res = cs.map(cid =&gt; {
            for (let p in ___grecaptcha_cfg.clients[cid]) {
                let c = {}
                cid &gt;= 10000 ? c.version = 'V3' : c.version = 'V2'
                let path = "___grecaptcha_cfg.clients[" + cid + "]." + p
                let pp = eval(path)
                if (typeof pp === 'object') {
                    for (let s in pp) {
                        let subpath = "___grecaptcha_cfg.clients[" + cid + "]." + p + "." + s
                        let sp = eval(subpath)
                        if (sp &amp;&amp; typeof sp === 'object' &amp;&amp; sp.hasOwnProperty('sitekey') &amp;&amp; sp.hasOwnProperty('size')) {
                            c.sitekey = eval(subpath + '.sitekey')
                            let cb = eval(subpath + '.callback')
                            if (cb == null) {
                                c.callback = null
                                c.function = null
                            }
                            else {
                                c.callback = subpath + '.callback'
                                cb != c.callback ? c.function = cb : c.function = null
                            }
                        }
                    }
                }
                return c
            }
        })
        return (res)
    } else {
        return (null)
    }
}</value>
  </data>
  <data name="Frame" xml:space="preserve">
    <value>() =&gt; {
      try {
        // Adds a contentWindow proxy to the provided iframe element
        const addContentWindowProxy = iframe =&gt; {
          const contentWindowProxy = {
            get(target, key) {
              // Now to the interesting part:
              // We actually make this thing behave like a regular iframe window,
              // by intercepting calls to e.g. `.self` and redirect it to the correct thing. :)
              // That makes it possible for these assertions to be correct:
              // iframe.contentWindow.self === window.top // must be false
              if (key === 'self') {
                return this
              }
              // iframe.contentWindow.frameElement === iframe // must be true
              if (key === 'frameElement') {
                return iframe
              }
              return Reflect.get(target, key)
            }
          }

          if (!iframe.contentWindow) {
            const proxy = new Proxy(window, contentWindowProxy)
            Object.defineProperty(iframe, 'contentWindow', {
              get() {
                return proxy
              },
              set(newValue) {
                return newValue // contentWindow is immutable
              },
              enumerable: true,
              configurable: false
            })
          }
        }

        // Handles iframe element creation, augments `srcdoc` property so we can intercept further
        const handleIframeCreation = (target, thisArg, args) =&gt; {
          const iframe = target.apply(thisArg, args)

          // We need to keep the originals around
          const _iframe = iframe
          const _srcdoc = _iframe.srcdoc

          // Add hook for the srcdoc property
          // We need to be very surgical here to not break other iframes by accident
          Object.defineProperty(iframe, 'srcdoc', {
            configurable: true, // Important, so we can reset this later
            get: function() {
              return _iframe.srcdoc
            },
            set: function(newValue) {
              addContentWindowProxy(this)
              // Reset property, the hook is only needed once
              Object.defineProperty(iframe, 'srcdoc', {
                configurable: false,
                writable: false,
                value: _srcdoc
              })
              _iframe.srcdoc = newValue
            }
          })
          return iframe
        }

        // Adds a hook to intercept iframe creation events
        const addIframeCreationSniffer = () =&gt; {
          /* global document */
          const createElement = {
            // Make toString() native
            get(target, key) {
              return Reflect.get(target, key)
            },
            apply: function(target, thisArg, args) {
              const isIframe =
                args &amp;&amp; args.length &amp;&amp; `${args[0]}`.toLowerCase() === 'iframe'
              if (!isIframe) {
                // Everything as usual
                return target.apply(thisArg, args)
              } else {
                return handleIframeCreation(target, thisArg, args)
              }
            }
          }
          // All this just due to iframes with srcdoc bug
          document.createElement = new Proxy(
            document.createElement,
            createElement
          )
        }

        // Let's go
        addIframeCreationSniffer()
      } catch (err) {
        // console.warn(err)
      }
    }</value>
  </data>
  <data name="Permissions" xml:space="preserve">
    <value>() =&gt; {
      const handler = {
        apply: function(target, ctx, args) {
          const param = (args || [])[0]

          if (param &amp;&amp; param.name &amp;&amp; param.name === 'notifications') {
            const result = { state: Notification.permission }
            Object.setPrototypeOf(result, PermissionStatus.prototype)
            return Promise.resolve(result)
          }

          return utils.cache.Reflect.apply(...arguments)
        }
      }

      utils.replaceWithProxy(
        window.navigator.permissions.__proto__, // eslint-disable-line no-proto
        'query',
        handler
      )
    }</value>
  </data>
  <data name="PluginEvasion" xml:space="preserve">
    <value>() =&gt; {
              function mockPluginsAndMimeTypes () {
                /* global MimeType MimeTypeArray PluginArray */

                // Disguise custom functions as being native
                const makeFnsNative = (fns = []) =&gt; {
                  const oldCall = Function.prototype.call
                  function call () {
                    return oldCall.apply(this, arguments)
                  }
                  // eslint-disable-next-line
                  Function.prototype.call = call

                  const nativeToStringFunctionString = Error.toString().replace(
                    /Error/g,
                    'toString'
                  )
                  const oldToString = Function.prototype.toString

                  function functionToString () {
                    for (const fn of fns) {
                      if (this === fn.ref) {
                        return `function ${fn.name}() { [native code] }`
                      }
                    }

                    if (this === functionToString) {
                      return nativeToStringFunctionString
                    }
                    return oldCall.call(oldToString, this)
                  }
                  // eslint-disable-next-line
                  Function.prototype.toString = functionToString
                }

                const mockedFns = []

                const fakeData = {
                  mimeTypes: [
                    {
                      type: 'application/pdf',
                      suffixes: 'pdf',
                      description: '',
                      __pluginName: 'Chrome PDF Viewer'
                    },
                    {
                      type: 'application/x-google-chrome-pdf',
                      suffixes: 'pdf',
                      description: 'Portable Document Format',
                      __pluginName: 'Chrome PDF Plugin'
                    },
                    {
                      type: 'application/x-nacl',
                      suffixes: '',
                      description: 'Native Client Executable',
                      enabledPlugin: Plugin,
                      __pluginName: 'Native Client'
                    },
                    {
                      type: 'application/x-pnacl',
                      suffixes: '',
                      description: 'Portable Native Client Executable',
                      __pluginName: 'Native Client'
                    }
                  ],
                  plugins: [
                    {
                      name: 'Chrome PDF Plugin',
                      filename: 'internal-pdf-viewer',
                      description: 'Portable Document Format'
                    },
                    {
                      name: 'Chrome PDF Viewer',
                      filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai',
                      description: ''
                    },
                    {
                      name: 'Native Client',
                      filename: 'internal-nacl-plugin',
                      description: ''
                    }
                  ],
                  fns: {
                    namedItem: instanceName =&gt; {
                      // Returns the Plugin/MimeType with the specified name.
                      const fn = function (name) {
                        if (!arguments.length) {
                          throw new TypeError(
                            `Failed to execute 'namedItem' on '${instanceName}': 1 argument required, but only 0 present.`
                          )
                        }
                        return this[name] || null
                      }
                      mockedFns.push({ ref: fn, name: 'namedItem' })
                      return fn
                    },
                    item: instanceName =&gt; {
                      // Returns the Plugin/MimeType at the specified index into the array.
                      const fn = function (index) {
                        if (!arguments.length) {
                          throw new TypeError(
                            `Failed to execute 'namedItem' on '${instanceName}': 1 argument required, but only 0 present.`
                          )
                        }
                        return this[index] || null
                      }
                      mockedFns.push({ ref: fn, name: 'item' })
                      return fn
                    },
                    refresh: instanceName =&gt; {
                      // Refreshes all plugins on the current page, optionally reloading documents.
                      const fn = function () {
                        return undefined
                      }
                      mockedFns.push({ ref: fn, name: 'refresh' })
                      return fn
                    }
                  }
                }
                // Poor mans _.pluck
                const getSubset = (keys, obj) =&gt;
                  keys.reduce((a, c) =&gt; ({ ...a, [c]: obj[c] }), {})

                function generateMimeTypeArray () {
                  const arr = fakeData.mimeTypes
                    .map(obj =&gt; getSubset(['type', 'suffixes', 'description'], obj))
                    .map(obj =&gt; Object.setPrototypeOf(obj, MimeType.prototype))
                  arr.forEach(obj =&gt; {
                    arr[obj.type] = obj
                  })

                  // Mock functions
                  arr.namedItem = fakeData.fns.namedItem('MimeTypeArray')
                  arr.item = fakeData.fns.item('MimeTypeArray')

                  return Object.setPrototypeOf(arr, MimeTypeArray.prototype)
                }

                const mimeTypeArray = generateMimeTypeArray()
                Object.defineProperty(navigator, 'mimeTypes', {
                  get: () =&gt; mimeTypeArray
                })

                function generatePluginArray () {
                  const arr = fakeData.plugins
                    .map(obj =&gt; getSubset(['name', 'filename', 'description'], obj))
                    .map(obj =&gt; {
                      const mimes = fakeData.mimeTypes.filter(
                        m =&gt; m.__pluginName === obj.name
                      )
                      // Add mimetypes
                      mimes.forEach((mime, index) =&gt; {
                        navigator.mimeTypes[mime.type].enabledPlugin = obj
                        obj[mime.type] = navigator.mimeTypes[mime.type]
                        obj[index] = navigator.mimeTypes[mime.type]
                      })
                      obj.length = mimes.length
                      return obj
                    })
                    .map(obj =&gt; {
                      // Mock functions
                      obj.namedItem = fakeData.fns.namedItem('Plugin')
                      obj.item = fakeData.fns.item('Plugin')
                      return obj
                    })
                    .map(obj =&gt; Object.setPrototypeOf(obj, Plugin.prototype))
                  arr.forEach(obj =&gt; {
                    arr[obj.name] = obj
                  })

                  // Mock functions
                  arr.namedItem = fakeData.fns.namedItem('PluginArray')
                  arr.item = fakeData.fns.item('PluginArray')
                  arr.refresh = fakeData.fns.refresh('PluginArray')

                  return Object.setPrototypeOf(arr, PluginArray.prototype)
                }

                const pluginArray = generatePluginArray()
                Object.defineProperty(navigator, 'plugins', {
                  get: () =&gt; pluginArray
                })

                // Make mockedFns toString() representation resemble a native function
                makeFnsNative(mockedFns)
              }
              try {
                const isPluginArray = navigator.plugins instanceof PluginArray
                const hasPlugins = isPluginArray &amp;&amp; navigator.plugins.length &gt; 0
                if (isPluginArray &amp;&amp; hasPlugins) {
                  return // nothing to do here
                }
                mockPluginsAndMimeTypes()
              } catch (err) {}
            }</value>
  </data>
  <data name="Runtime" xml:space="preserve">
    <value>() =&gt; {
        if (!window.chrome) {
          // Use the exact property descriptor found in headful Chrome
          // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`
          Object.defineProperty(window, 'chrome', {
            writable: true,
            enumerable: true,
            configurable: false, // note!
            value: {} // We'll extend that later
          })
        }

        // That means we're running headful and don't need to mock anything
        const existsAlready = 'runtime' in window.chrome
        // `chrome.runtime` is only exposed on secure origins
        const isNotSecure = !window.location.protocol.startsWith('https')
        if (existsAlready || isNotSecure) {
          return // Nothing to do here
        }

        window.chrome.runtime = {
          // There's a bunch of static data in that property which doesn't seem to change,
          // we should periodically check for updates: `JSON.stringify(window.chrome.runtime, null, 2)`
          // `chrome.runtime.id` is extension related and returns undefined in Chrome
          get id() {
            return undefined
          },
          // These two require more sophisticated mocks
          connect: null,
          sendMessage: null
        }

        const makeCustomRuntimeErrors = (preamble, method, extensionId) =&gt; ({
          NoMatchingSignature: new TypeError(
            preamble + `No matching signature.`
          ),
          MustSpecifyExtensionID: new TypeError(
            preamble +
              `${method} called from a webpage must specify an Extension ID (string) for its first argument.`
          ),
          InvalidExtensionID: new TypeError(
            preamble + `Invalid extension id: '${extensionId}'`
          )
        })

        // Valid Extension IDs are 32 characters in length and use the letter `a` to `p`:
        // https://source.chromium.org/chromium/chromium/src/+/master:components/crx_file/id_util.cc;drc=14a055ccb17e8c8d5d437fe080faba4c6f07beac;l=90
        const isValidExtensionID = str =&gt;
          str.length === 32 &amp;&amp; str.toLowerCase().match(/^[a-p]+$/)

        /** Mock `chrome.runtime.sendMessage` */
        const sendMessageHandler = {
          apply: function(target, ctx, args) {
            const [extensionId, options, responseCallback] = args || []

            // Define custom errors
            const errorPreamble = `Error in invocation of runtime.sendMessage(optional string extensionId, any message, optional object options, optional function responseCallback): `
            const Errors = makeCustomRuntimeErrors(
              errorPreamble,
              `chrome.runtime.sendMessage()`,
              extensionId
            )

            // Check if the call signature looks ok
            const noArguments = args.length === 0
            const tooManyArguments = args.length &gt; 4
            const incorrectOptions = options &amp;&amp; typeof options !== 'object'
            const incorrectResponseCallback =
              responseCallback &amp;&amp; typeof responseCallback !== 'function'
            if (
              noArguments ||
              tooManyArguments ||
              incorrectOptions ||
              incorrectResponseCallback
            ) {
              throw Errors.NoMatchingSignature
            }

            // At least 2 arguments are required before we even validate the extension ID
            if (args.length &lt; 2) {
              throw Errors.MustSpecifyExtensionID
            }

            // Now let's make sure we got a string as extension ID
            if (typeof extensionId !== 'string') {
              throw Errors.NoMatchingSignature
            }

            if (!isValidExtensionID(extensionId)) {
              throw Errors.InvalidExtensionID
            }

            return undefined // Normal behavior
          }
        }
        utils.mockWithProxy(
          window.chrome.runtime,
          'sendMessage',
          function sendMessage() {},
          sendMessageHandler
        )

        /**
         * Mock `chrome.runtime.connect`
         *
         * @see https://developer.chrome.com/apps/runtime#method-connect
         */
        const connectHandler = {
          apply: function(target, ctx, args) {
            const [extensionId, connectInfo] = args || []

            // Define custom errors
            const errorPreamble = `Error in invocation of runtime.connect(optional string extensionId, optional object connectInfo): `
            const Errors = makeCustomRuntimeErrors(
              errorPreamble,
              `chrome.runtime.connect()`,
              extensionId
            )

            // Behavior differs a bit from sendMessage:
            const noArguments = args.length === 0
            const emptyStringArgument = args.length === 1 &amp;&amp; extensionId === ''
            if (noArguments || emptyStringArgument) {
              throw Errors.MustSpecifyExtensionID
            }

            const tooManyArguments = args.length &gt; 2
            const incorrectConnectInfoType =
              connectInfo &amp;&amp; typeof connectInfo !== 'object'

            if (tooManyArguments || incorrectConnectInfoType) {
              throw Errors.NoMatchingSignature
            }

            const extensionIdIsString = typeof extensionId === 'string'
            if (extensionIdIsString &amp;&amp; extensionId === '') {
              throw Errors.MustSpecifyExtensionID
            }
            if (extensionIdIsString &amp;&amp; !isValidExtensionID(extensionId)) {
              throw Errors.InvalidExtensionID
            }

            // There's another edge-case here: extensionId is optional so we might find a connectInfo object as first param, which we need to validate
            const validateConnectInfo = ci =&gt; {
              // More than a first param connectInfo as been provided
              if (args.length &gt; 1) {
                throw Errors.NoMatchingSignature
              }
              // An empty connectInfo has been provided
              if (Object.keys(ci).length === 0) {
                throw Errors.MustSpecifyExtensionID
              }
              // Loop over all connectInfo props an check them
              Object.entries(ci).forEach(([k, v]) =&gt; {
                const isExpected = ['name', 'includeTlsChannelId'].includes(k)
                if (!isExpected) {
                  throw new TypeError(
                    errorPreamble + `Unexpected property: '${k}'.`
                  )
                }
                const MismatchError = (propName, expected, found) =&gt;
                  TypeError(
                    errorPreamble +
                      `Error at property '${propName}': Invalid type: expected ${expected}, found ${found}.`
                  )
                if (k === 'name' &amp;&amp; typeof v !== 'string') {
                  throw MismatchError(k, 'string', typeof v)
                }
                if (k === 'includeTlsChannelId' &amp;&amp; typeof v !== 'boolean') {
                  throw MismatchError(k, 'boolean', typeof v)
                }
              })
            }
            if (typeof extensionId === 'object') {
              validateConnectInfo(extensionId)
              throw Errors.MustSpecifyExtensionID
            }

            // Unfortunately even when the connect fails Chrome will return an object with methods we need to mock as well
            return utils.patchToStringNested(makeConnectResponse())
          }
        }
        utils.mockWithProxy(
          window.chrome.runtime,
          'connect',
          function connect() {},
          connectHandler
        )

        function makeConnectResponse() {
          const onSomething = () =&gt; ({
            addListener: function addListener() {},
            dispatch: function dispatch() {},
            hasListener: function hasListener() {},
            hasListeners: function hasListeners() {
              return false
            },
            removeListener: function removeListener() {}
          })

          const response = {
            name: '',
            sender: undefined,
            disconnect: function disconnect() {},
            onDisconnect: onSomething(),
            onMessage: onSomething(),
            postMessage: function postMessage() {
              if (!arguments.length) {
                throw new TypeError(`Insufficient number of arguments.`)
              }
              throw new Error(`Attempting to use a disconnected port object`)
            }
          }
          return response
        }
      }</value>
  </data>
  <data name="SCI" xml:space="preserve">
    <value>() =&gt; {
      if (!window.chrome) {
        // Use the exact property descriptor found in headful Chrome
        // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`
        Object.defineProperty(window, 'chrome', {
          writable: true,
          enumerable: true,
          configurable: false, // note!
          value: {} // We'll extend that later
        })
      }

      // That means we're running headful and don't need to mock anything
      if ('csi' in window.chrome) {
        return // Nothing to do here
      }

      // Check that the Navigation Timing API v1 is available, we need that
      if (!window.performance || !window.performance.timing) {
        return
      }

      const { timing } = window.performance

      window.chrome.csi = function() {
        return {
          onloadT: timing.domContentLoadedEventEnd,
          startE: timing.navigationStart,
          pageT: Date.now() - timing.navigationStart,
          tran: 15 // Transition type or something
        }
      }
      utils.patchToString(window.chrome.csi)
    }</value>
  </data>
  <data name="Utils" xml:space="preserve">
    <value>/**
 * A set of shared utility functions specifically for the purpose of modifying native browser APIs without leaving traces.
 *
 * Meant to be passed down in puppeteer and used in the context of the page (everything in here runs in NodeJS as well as a browser).
 *
 * Note: If for whatever reason you need to use this outside of `puppeteer-extra`:
 * Just remove the `module.exports` statement at the very bottom, the rest can be copy pasted into any browser context.
 *
 * Alternatively take a look at the `extract-stealth-evasions` package to create a finished bundle which includes these utilities.
 *
 */

const utils = {}
/**
 * Wraps a JS Proxy Handler and strips it's presence from error stacks, in case the traps throw.
 *
 * The presence of a JS Proxy can be revealed as it shows up in error stack traces.
 *
 * @param {object} handler - The JS Proxy handler to wrap
 */
utils.stripProxyFromErrors = (handler = {}) =&gt; {
  const newHandler = {}
  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw
  const traps = Object.getOwnPropertyNames(handler)
  traps.forEach(trap =&gt; {
    newHandler[trap] = function() {
      try {
        // Forward the call to the defined proxy handler
        return handler[trap].apply(this, arguments || [])
      } catch (err) {
        // Stack traces differ per browser, we only support chromium based ones currently
        if (!err || !err.stack || !err.stack.includes(`at `)) {
          throw err
        }

        // When something throws within one of our traps the Proxy will show up in error stacks
        // An earlier implementation of this code would simply strip lines with a blacklist,
        // but it makes sense to be more surgical here and only remove lines related to our Proxy.
        // We try to use a known "anchor" line for that and strip it with everything above it.
        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.

        const stripWithBlacklist = stack =&gt; {
          const blacklist = [
            `at Reflect.${trap} `, // e.g. Reflect.get or Reflect.apply
            `at Object.${trap} `, // e.g. Object.get or Object.apply
            `at Object.newHandler.&lt;computed&gt; [as ${trap}] ` // caused by this very wrapper :-)
          ]
          return (
            err.stack
              .split('\n')
              // Always remove the first (file) line in the stack (guaranteed to be our proxy)
              .filter((line, index) =&gt; index !== 1)
              // Check if the line starts with one of our blacklisted strings
              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))
              .join('\n')
          )
        }

        const stripWithAnchor = stack =&gt; {
          const stackArr = stack.split('\n')
          const anchor = `at Object.newHandler.&lt;computed&gt; [as ${trap}] ` // Known first Proxy line in chromium
          const anchorIndex = stackArr.findIndex(line =&gt;
            line.trim().startsWith(anchor)
          )
          if (anchorIndex === -1) {
            return false // 404, anchor not found
          }
          // Strip everything from the top until we reach the anchor line
          // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)
          stackArr.splice(1, anchorIndex)
          return stackArr.join('\n')
        }

        // Try using the anchor method, fallback to blacklist if necessary
        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)

        throw err // Re-throw our now sanitized error
      }
    }
  })
  return newHandler
}

/**
 * Strip error lines from stack traces until (and including) a known line the stack.
 *
 * @param {object} err - The error to sanitize
 * @param {string} anchor - The string the anchor line starts with
 */
utils.stripErrorWithAnchor = (err, anchor) =&gt; {
  const stackArr = err.stack.split('\n')
  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))
  if (anchorIndex === -1) {
    return err // 404, anchor not found
  }
  // Strip everything from the top until we reach the anchor line (remove anchor line as well)
  // Note: We're keeping the 1st line (zero index) as it's unrelated (e.g. `TypeError`)
  stackArr.splice(1, anchorIndex)
  err.stack = stackArr.join('\n')
  return err
}

/**
 * Replace the property of an object in a stealthy way.
 *
 * Note: You also want to work on the prototype of an object most often,
 * as you'd otherwise leave traces (e.g. showing up in Object.getOwnPropertyNames(obj)).
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
 *
 * @example
 * replaceProperty(WebGLRenderingContext.prototype, 'getParameter', { value: "alice" })
 * // or
 * replaceProperty(Object.getPrototypeOf(navigator), 'languages', { get: () =&gt; ['en-US', 'en'] })
 *
 * @param {object} obj - The object which has the property to replace
 * @param {string} propName - The property name to replace
 * @param {object} descriptorOverrides - e.g. { value: "alice" }
 */
utils.replaceProperty = (obj, propName, descriptorOverrides = {}) =&gt; {
  return Object.defineProperty(obj, propName, {
    // Copy over the existing descriptors (writable, enumerable, configurable, etc)
    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),
    // Add our overrides (e.g. value, get())
    ...descriptorOverrides
  })
}

/**
 * Preload a cache of function copies and data.
 *
 * For a determined enough observer it would be possible to overwrite and sniff usage of functions
 * we use in our internal Proxies, to combat that we use a cached copy of those functions.
 *
 * This is evaluated once per execution context (e.g. window)
 */
utils.preloadCache = () =&gt; {
  if (utils.cache) {
    return
  }
  utils.cache = {
    // Used in our proxies
    Reflect: {
      get: Reflect.get.bind(Reflect),
      apply: Reflect.apply.bind(Reflect)
    },
    // Used in `makeNativeString`
    nativeToStringStr: Function.toString + '' // =&gt; `function toString() { [native code] }`
  }
}

/**
 * Utility function to generate a cross-browser `toString` result representing native code.
 *
 * There's small differences: Chromium uses a single line, whereas FF &amp; Webkit uses multiline strings.
 * To future-proof this we use an existing native toString result as the basis.
 *
 * The only advantage we have over the other team is that our JS runs first, hence we cache the result
 * of the native toString result once, so they cannot spoof it afterwards and reveal that we're using it.
 *
 * Note: Whenever we add a `Function.prototype.toString` proxy we should preload the cache before,
 * by executing `utils.preloadCache()` before the proxy is applied (so we don't cause recursive lookups).
 *
 * @example
 * makeNativeString('foobar') // =&gt; `function foobar() { [native code] }`
 *
 * @param {string} [name] - Optional function name
 */
utils.makeNativeString = (name = '') =&gt; {
  // Cache (per-window) the original native toString or use that if available
  utils.preloadCache()
  return utils.cache.nativeToStringStr.replace('toString', name || '')
}

/**
 * Helper function to modify the `toString()` result of the provided object.
 *
 * Note: Use `utils.redirectToString` instead when possible.
 *
 * There's a quirk in JS Proxies that will cause the `toString()` result to differ from the vanilla Object.
 * If no string is provided we will generate a `[native code]` thing based on the name of the property object.
 *
 * @example
 * patchToString(WebGLRenderingContext.prototype.getParameter, 'function getParameter() { [native code] }')
 *
 * @param {object} obj - The object for which to modify the `toString()` representation
 * @param {string} str - Optional string used as a return value
 */
utils.patchToString = (obj, str = '') =&gt; {
  utils.preloadCache()

  const toStringProxy = new Proxy(Function.prototype.toString, {
    apply: function(target, ctx) {
      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + ""`
      if (ctx === Function.prototype.toString) {
        return utils.makeNativeString('toString')
      }
      // `toString` targeted at our proxied Object detected
      if (ctx === obj) {
        // We either return the optional string verbatim or derive the most desired result automatically
        return str || utils.makeNativeString(obj.name)
      }
      // Check if the toString protype of the context is the same as the global prototype,
      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case
      const hasSameProto = Object.getPrototypeOf(
        Function.prototype.toString
      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins
      if (!hasSameProto) {
        // Pass the call on to the local Function.prototype.toString instead
        return ctx.toString()
      }
      return target.call(ctx)
    }
  })
  utils.replaceProperty(Function.prototype, 'toString', {
    value: toStringProxy
  })
}

/**
 * Make all nested functions of an object native.
 *
 * @param {object} obj
 */
utils.patchToStringNested = (obj = {}) =&gt; {
  return utils.execRecursively(obj, ['function'], utils.patchToString)
}

/**
 * Redirect toString requests from one object to another.
 *
 * @param {object} proxyObj - The object that toString will be called on
 * @param {object} originalObj - The object which toString result we wan to return
 */
utils.redirectToString = (proxyObj, originalObj) =&gt; {
  utils.preloadCache()

  const toStringProxy = new Proxy(Function.prototype.toString, {
    apply: function(target, ctx) {
      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + ""`
      if (ctx === Function.prototype.toString) {
        return utils.makeNativeString('toString')
      }

      // `toString` targeted at our proxied Object detected
      if (ctx === proxyObj) {
        const fallback = () =&gt;
          originalObj &amp;&amp; originalObj.name
            ? utils.makeNativeString(originalObj.name)
            : utils.makeNativeString(proxyObj.name)

        // Return the toString representation of our original object if possible
        return originalObj + '' || fallback()
      }

      // Check if the toString protype of the context is the same as the global prototype,
      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case
      const hasSameProto = Object.getPrototypeOf(
        Function.prototype.toString
      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins
      if (!hasSameProto) {
        // Pass the call on to the local Function.prototype.toString instead
        return ctx.toString()
      }

      return target.call(ctx)
    }
  })
  utils.replaceProperty(Function.prototype, 'toString', {
    value: toStringProxy
  })
}

/**
 * All-in-one method to replace a property with a JS Proxy using the provided Proxy handler with traps.
 *
 * Will stealthify these aspects (strip error stack traces, redirect toString, etc).
 * Note: This is meant to modify native Browser APIs and works best with prototype objects.
 *
 * @example
 * replaceWithProxy(WebGLRenderingContext.prototype, 'getParameter', proxyHandler)
 *
 * @param {object} obj - The object which has the property to replace
 * @param {string} propName - The name of the property to replace
 * @param {object} handler - The JS Proxy handler to use
 */
utils.replaceWithProxy = (obj, propName, handler) =&gt; {
  utils.preloadCache()
  const originalObj = obj[propName]
  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))

  utils.replaceProperty(obj, propName, { value: proxyObj })
  utils.redirectToString(proxyObj, originalObj)

  return true
}

/**
 * All-in-one method to mock a non-existing property with a JS Proxy using the provided Proxy handler with traps.
 *
 * Will stealthify these aspects (strip error stack traces, redirect toString, etc).
 *
 * @example
 * mockWithProxy(chrome.runtime, 'sendMessage', function sendMessage() {}, proxyHandler)
 *
 * @param {object} obj - The object which has the property to replace
 * @param {string} propName - The name of the property to replace or create
 * @param {object} pseudoTarget - The JS Proxy target to use as a basis
 * @param {object} handler - The JS Proxy handler to use
 */
utils.mockWithProxy = (obj, propName, pseudoTarget, handler) =&gt; {
  utils.preloadCache()
  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))

  utils.replaceProperty(obj, propName, { value: proxyObj })
  utils.patchToString(proxyObj)

  return true
}

/**
 * All-in-one method to create a new JS Proxy with stealth tweaks.
 *
 * This is meant to be used whenever we need a JS Proxy but don't want to replace or mock an existing known property.
 *
 * Will stealthify certain aspects of the Proxy (strip error stack traces, redirect toString, etc).
 *
 * @example
 * createProxy(navigator.mimeTypes.__proto__.namedItem, proxyHandler) // =&gt; Proxy
 *
 * @param {object} pseudoTarget - The JS Proxy target to use as a basis
 * @param {object} handler - The JS Proxy handler to use
 */
utils.createProxy = (pseudoTarget, handler) =&gt; {
  utils.preloadCache()
  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))
  utils.patchToString(proxyObj)

  return proxyObj
}

/**
 * Helper function to split a full path to an Object into the first part and property.
 *
 * @example
 * splitObjPath(`HTMLMediaElement.prototype.canPlayType`)
 * // =&gt; {objName: "HTMLMediaElement.prototype", propName: "canPlayType"}
 *
 * @param {string} objPath - The full path to an object as dot notation string
 */
utils.splitObjPath = objPath =&gt; ({
  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`
  objName: objPath
    .split('.')
    .slice(0, -1)
    .join('.'),
  // Extract last dot entry ==&gt; `canPlayType`
  propName: objPath.split('.').slice(-1)[0]
})

/**
 * Convenience method to replace a property with a JS Proxy using the provided objPath.
 *
 * Supports a full path (dot notation) to the object as string here, in case that makes it easier.
 *
 * @example
 * replaceObjPathWithProxy('WebGLRenderingContext.prototype.getParameter', proxyHandler)
 *
 * @param {string} objPath - The full path to an object (dot notation string) to replace
 * @param {object} handler - The JS Proxy handler to use
 */
utils.replaceObjPathWithProxy = (objPath, handler) =&gt; {
  const { objName, propName } = utils.splitObjPath(objPath)
  const obj = eval(objName) // eslint-disable-line no-eval
  return utils.replaceWithProxy(obj, propName, handler)
}

/**
 * Traverse nested properties of an object recursively and apply the given function on a whitelist of value types.
 *
 * @param {object} obj
 * @param {array} typeFilter - e.g. `['function']`
 * @param {Function} fn - e.g. `utils.patchToString`
 */
utils.execRecursively = (obj = {}, typeFilter = [], fn) =&gt; {
  function recurse(obj) {
    for (const key in obj) {
      if (obj[key] === undefined) {
        continue
      }
      if (obj[key] &amp;&amp; typeof obj[key] === 'object') {
        recurse(obj[key])
      } else {
        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) {
          fn.call(this, obj[key])
        }
      }
    }
  }
  recurse(obj)
  return obj
}

/**
 * Everything we run through e.g. `page.evaluate` runs in the browser context, not the NodeJS one.
 * That means we cannot just use reference variables and functions from outside code, we need to pass everything as a parameter.
 *
 * Unfortunately the data we can pass is only allowed to be of primitive types, regular functions don't survive the built-in serialization process.
 * This utility function will take an object with functions and stringify them, so we can pass them down unharmed as strings.
 *
 * We use this to pass down our utility functions as well as any other functions (to be able to split up code better).
 *
 * @see utils.materializeFns
 *
 * @param {object} fnObj - An object containing functions as properties
 */
utils.stringifyFns = (fnObj = { hello: () =&gt; 'world' }) =&gt; {
  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine
  // https://github.com/feross/fromentries
  function fromEntries(iterable) {
    return [...iterable].reduce((obj, [key, val]) =&gt; {
      obj[key] = val
      return obj
    }, {})
  }
  return (Object.fromEntries || fromEntries)(
    Object.entries(fnObj)
      .filter(([key, value]) =&gt; typeof value === 'function')
      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval
  )
}

/**
 * Utility function to reverse the process of `utils.stringifyFns`.
 * Will materialize an object with stringified functions (supports classic and fat arrow functions).
 *
 * @param {object} fnStrObj - An object containing stringified functions as properties
 */
utils.materializeFns = (fnStrObj = { hello: "() =&gt; 'world'" }) =&gt; {
  return Object.fromEntries(
    Object.entries(fnStrObj).map(([key, value]) =&gt; {
      if (value.startsWith('function')) {
        // some trickery is needed to make oldschool functions work :-)
        return [key, eval(`() =&gt; ${value}`)()] // eslint-disable-line no-eval
      } else {
        // arrow functions just work
        return [key, eval(value)] // eslint-disable-line no-eval
      }
    })
  )
}


    console.warn('testtt');
    if (!window.chrome) {
        // Use the exact property descriptor found in headful Chrome
        // fetch it via `Object.getOwnPropertyDescriptor(window, 'chrome')`
        Object.defineProperty(window, 'chrome', {
            writable: true,
            enumerable: true,
            configurable: false, // note!
            value: {} // We'll extend that later
        })
    }

    // That means we're running headful and don't need to mock anything
    if ('app' in window.chrome) {
    }

    const makeError = {
        ErrorInInvocation: fn =&gt; {
            const err = new TypeError(`Error in invocation of app.${fn}()`)
            return utils.stripErrorWithAnchor(
                err,
                `at ${fn} (eval at &lt;anonymous&gt;`
            )
        }
    }

    // There's a some static data in that property which doesn't seem to change,
    // we should periodically check for updates: `JSON.stringify(window.app, null, 2)`
    const STATIC_DATA = JSON.parse(
        `
{
  "isInstalled": false,
  "InstallState": {
    "DISABLED": "disabled",
    "INSTALLED": "installed",
    "NOT_INSTALLED": "not_installed"
  },
  "RunningState": {
    "CANNOT_RUN": "cannot_run",
    "READY_TO_RUN": "ready_to_run",
    "RUNNING": "running"
  }
}
        `.trim()
    )

    window.chrome.app = {
        ...STATIC_DATA,

        get isInstalled() {
            return false
        },

        getDetails: function getDetails() {
            if (arguments.length) {
                throw makeError.ErrorInInvocation(`getDetails`)
            }
            return null
        },
        getIsInstalled: function getDetails() {
            if (arguments.length) {
                throw makeError.ErrorInInvocation(`getIsInstalled`)
            }
            return false
        },
        runningState: function getDetails() {
            if (arguments.length) {
                throw makeError.ErrorInInvocation(`runningState`)
            }
            return 'cannot_run'
        }
    }
    utils.patchToStringNested(window.chrome.app)</value>
  </data>
  <data name="webGl" xml:space="preserve">
    <value>() =&gt; {
      const getParameterProxyHandler = {
        apply: function(target, ctx, args) {
          const param = (args || [])[0]
          // UNMASKED_VENDOR_WEBGL
          if (param === 37445) {
            'Intel Inc.' // default in headless: Google Inc.
          }
          // UNMASKED_RENDERER_WEBGL
          if (param === 37446) {
            'Intel Iris OpenGL Engine' // default in headless: Google SwiftShader
          }
          return utils.cache.Reflect.apply(target, ctx, args)
        }
      }

      // There's more than one WebGL rendering context
      // https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext#Browser_compatibility
      // To find out the original values here: Object.getOwnPropertyDescriptors(WebGLRenderingContext.prototype.getParameter)
      const addProxy = (obj, propName) =&gt; {
        utils.replaceWithProxy(obj, propName, getParameterProxyHandler)
      }
      // For whatever weird reason loops don't play nice with Object.defineProperty, here's the next best thing:
      addProxy(WebGLRenderingContext.prototype, 'getParameter')
      addProxy(WebGL2RenderingContext.prototype, 'getParameter')
    }</value>
  </data>
</root>